<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BAFILYRD</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .game-container {
      position: relative;
      overflow: hidden;
      background: #0a0a0a;
    }

    .background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      overflow: hidden;
    }

    .column {
      position: absolute;
      display: flex;
      flex-direction: column;
      font-size: 20px;
      line-height: 0.75;
      will-change: transform;
      white-space: pre;
      transform-origin: top;
    }

    .column:nth-child(8n+1) {
      color: #e0e0e0;
      animation: scrollDown 5s linear infinite;
    }

    .column:nth-child(8n+2) {
      color: #a0a0a0;
      animation: scrollUp 5s linear infinite;
    }

    .column:nth-child(8n+3) {
      color: #e0e0e0;
      animation: scrollDown 4s linear infinite;
    }

    .column:nth-child(8n+4) {
      color: #a0a0a0;
      animation: scrollUp 4s linear infinite;
    }

    .column:nth-child(8n+5) {
      color: #e0e0e0;
      animation: scrollDown 3s linear infinite;
    }

    .column:nth-child(8n+6) {
      color: #a0a0a0;
      animation: scrollUp 3s linear infinite;
    }

    .column:nth-child(8n+7) {
      color: #e0e0e0;
      animation: scrollDown 2s linear infinite;
    }

    .column:nth-child(8n+8) {
      color: #a0a0a0;
      animation: scrollUp 2s linear infinite;
    }

    @keyframes scrollDown {
      0% {
        transform: translateY(-63px) scaleY(0.7);
      }

      100% {
        transform: translateY(0) scaleY(0.7);
      }
    }

    @keyframes scrollUp {
      0% {
        transform: translateY(0) scaleY(0.7);
      }

      100% {
        transform: translateY(-63px) scaleY(0.7);
      }
    }

    canvas {
      display: block;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
</head>

<body>
  <div class="game-container" id="gameContainer">
    <div class="background" id="background"></div>
    <canvas id="game"></canvas>
  </div>
  <script>
    const container = document.getElementById('gameContainer');
    const background = document.getElementById('background');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Base game dimensions (2:3 ratio)
    const BASE_WIDTH = 480;
    const BASE_HEIGHT = 720;

    // Music configuration
    const BASE_URL = 'https://bafilyrd.loiyaa.com/';
    const isLocal = window.location.protocol === 'file:';
    const TRACK_COUNT = 4;
    const SILENCE_BETWEEN_TRACKS = 4000; // 4 seconds

    // Music state
    let musicPlaylist = [];
    let currentTrackIndex = 0;
    let audioElement = null;
    let musicStarted = false;
    let isTransitioning = false;

    // Shuffle array (Fisher-Yates)
    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Generate shuffled playlist
    function generatePlaylist() {
      const tracks = [];
      for (let i = 1; i <= TRACK_COUNT; i++) {
        const trackNum = i.toString().padStart(2, '0');
        const trackPath = isLocal
          ? `assets/track${trackNum}.mp3`
          : `${BASE_URL}assets/track${trackNum}.mp3`;
        tracks.push(trackPath);
      }
      return shuffleArray(tracks);
    }

    // Play next track
    function playNextTrack() {
      if (!musicStarted || isTransitioning) return;
      isTransitioning = true;

      // If we've played all tracks, reshuffle
      if (currentTrackIndex >= musicPlaylist.length) {
        musicPlaylist = generatePlaylist();
        currentTrackIndex = 0;
      }

      const trackPath = musicPlaylist[currentTrackIndex];
      currentTrackIndex++;

      // Clean up old audio element completely
      if (audioElement) {
        audioElement.pause();
        audioElement.removeAttribute('src');
        audioElement.load();
        audioElement = null;
      }

      // Create fresh audio element
      audioElement = new Audio();
      audioElement.volume = 0.5;

      // Set up event handlers BEFORE setting src
      audioElement.onended = () => {
        isTransitioning = false;
        // Wait for silence period, then play next
        setTimeout(playNextTrack, SILENCE_BETWEEN_TRACKS);
      };

      audioElement.onerror = () => {
        console.warn('Could not load track:', trackPath);
        isTransitioning = false;
        // Try next track after a short delay
        setTimeout(playNextTrack, 1000);
      };

      audioElement.oncanplaythrough = () => {
        isTransitioning = false;
        audioElement.play().catch(e => {
          console.warn('Playback failed:', e);
        });
      };

      // Now set the source
      audioElement.src = trackPath;
      audioElement.load();
    }

    // Start music (call after user interaction)
    function startMusic() {
      if (musicStarted) return;
      musicStarted = true;
      isTransitioning = false;
      musicPlaylist = generatePlaylist();
      currentTrackIndex = 0;
      playNextTrack();
    }

    // Pause/resume music on tab visibility change
    document.addEventListener('visibilitychange', () => {
      if (!audioElement) return;
      if (document.hidden) {
        audioElement.pause();
      } else {
        if (musicStarted && gameState === 'playing') {
          audioElement.play().catch(() => { });
        }
      }
    });

    // Remix SDK Integration
    function initRemixSDK() {
      if (!window.FarcadeSDK) return;

      // Signal ready when game loads
      window.FarcadeSDK.singlePlayer.actions.ready();
      console.log('Remix SDK: Game ready signal sent.');

      // Handle play again requests from Remix
      window.FarcadeSDK.on('play_again', () => {
        console.log('Remix SDK: Play again requested.');
        startGame();
      });

      // Handle mute/unmute requests from Remix
      window.FarcadeSDK.on('toggle_mute', (data) => {
        console.log('Remix SDK: Mute toggle requested, isMuted:', data.isMuted);
        if (audioElement) {
          audioElement.muted = data.isMuted;
        }
      });

      console.log('Remix SDK: Event handlers registered.');
    }

    function signalGameOver(finalScore) {
      if (!window.FarcadeSDK) return;
      window.FarcadeSDK.singlePlayer.actions.gameOver({ score: finalScore });
      console.log('Remix SDK: Game over signal sent with score:', finalScore);
    }

    // Game constants
    const BIRD_SIZE = 30;
    const GRAVITY = 800;
    const FLAP_VELOCITY = -360;
    const PIPE_WIDTH = 50;
    const PIPE_GAP = 210;
    const PIPE_SPEED = 150;
    const SPEED_INCREMENT = 8; // Linear speed increase per pipe
    const INITIAL_PIPE_INTERVAL = 400;
    const INITIAL_BIRDS = 128;
    const FLAP_RADIUS = 64;

    // Mobile detection for performance optimization
    const IS_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
      || (navigator.maxTouchPoints > 1 && window.innerWidth < 1024);
    const FLAP_MAX_DELAY = 200;
    const PIPES_PER_COLOR = 8;

    // Color themes: [glow/stroke, fill dark, fill light]
    const COLOR_THEMES = [
      { glow: '#00ffff', dark: '#0d3d3d', light: '#0a4a4a' }, // Cyan
      { glow: '#ff3366', dark: '#3d0d1a', light: '#4a0a20' }, // Red/Pink
      { glow: '#00ff88', dark: '#0d3d2a', light: '#0a4a35' }, // Green
      { glow: '#aa66ff', dark: '#2a0d3d', light: '#350a4a' }, // Purple
      { glow: '#ffaa00', dark: '#3d2a0d', light: '#4a350a' }, // Orange
      { glow: '#ff66aa', dark: '#3d0d2a', light: '#4a0a35' }, // Pink
      { glow: '#66ffaa', dark: '#0d3d2a', light: '#0a4a35' }, // Mint
      { glow: '#ffff00', dark: '#3d3d0d', light: '#4a4a0a' }, // Yellow
    ];

    let currentColorIndex = 0;
    let pipesPassed = 0;
    let colorTransitionProgress = 0; // 0 = fully current color, 1 = fully next color
    let isTransitioningColor = false;
    const COLOR_TRANSITION_SPEED = 2; // Full transition in 0.5 seconds

    // Color interpolation for smooth transitions
    function lerpColor(color1, color2, t) {
      const r1 = parseInt(color1.slice(1, 3), 16);
      const g1 = parseInt(color1.slice(3, 5), 16);
      const b1 = parseInt(color1.slice(5, 7), 16);
      const r2 = parseInt(color2.slice(1, 3), 16);
      const g2 = parseInt(color2.slice(3, 5), 16);
      const b2 = parseInt(color2.slice(5, 7), 16);

      const r = Math.round(r1 + (r2 - r1) * t);
      const g = Math.round(g1 + (g2 - g1) * t);
      const b = Math.round(b1 + (b2 - b1) * t);

      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function getCurrentTheme() {
      if (colorTransitionProgress <= 0) {
        return COLOR_THEMES[currentColorIndex];
      }

      const currentTheme = COLOR_THEMES[currentColorIndex];
      const nextTheme = COLOR_THEMES[(currentColorIndex + 1) % COLOR_THEMES.length];

      return {
        glow: lerpColor(currentTheme.glow, nextTheme.glow, colorTransitionProgress),
        dark: lerpColor(currentTheme.dark, nextTheme.dark, colorTransitionProgress),
        light: lerpColor(currentTheme.light, nextTheme.light, colorTransitionProgress)
      };
    }

    function updateColorTransition(deltaTime) {
      if (!isTransitioningColor) return;

      colorTransitionProgress += COLOR_TRANSITION_SPEED * deltaTime;

      if (colorTransitionProgress >= 1) {
        // Transition complete - move to next color
        currentColorIndex = (currentColorIndex + 1) % COLOR_THEMES.length;
        colorTransitionProgress = 0;
        isTransitioningColor = false;
      }
    }

    function triggerColorTransition() {
      if (!isTransitioningColor) {
        isTransitioningColor = true;
        colorTransitionProgress = 0;
      }
    }

    // Check if actually running inside Remix (SDK loaded AND in iframe)
    function isInRemix() {
      return window.FarcadeSDK && window.self !== window.top;
    }

    const BIRD_COLORS = [
      '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
      '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE',
      '#85C1E9', '#F8B500', '#FF7F50', '#00CED1', '#FF69B4',
      '#7FFF00', '#DC143C', '#00BFFF', '#FF4500', '#9370DB',
      '#3CB371', '#FFB6C1', '#20B2AA', '#FF8C00', '#BA55D3',
      '#32CD32', '#FF1493', '#00FA9A', '#FF6347', '#48D1CC',
      '#ADFF2F', '#DB7093'
    ];

    // Game state
    let scale = 1;
    let gameState = 'start';
    let birds = [];
    let pipes = [];
    let score = 0;
    let nextBirdId = 0;
    let currentPipeSpeed = PIPE_SPEED;
    let lastPipeDistance = 0;
    let lastTime = null;
    let mouseX = BASE_WIDTH / 2;
    let mouseY = BASE_HEIGHT / 2;
    let pendingFlaps = [];

    // Rune background
    const runes = ['·õö', '·öÆ', '·õÅ', '·ö§', '·õÜ', '·õÜ'];

    function createColumns() {
      background.innerHTML = '';
      const columnWidth = 15;
      const numColumns = Math.ceil(container.offsetWidth / columnWidth) + 2; // Extra columns to prevent bleeding
      const runeHeight = 15 * 0.7;
      const runeSequenceHeight = 6 * runeHeight;
      const sequencesNeeded = Math.ceil(container.offsetHeight / runeSequenceHeight) + 3;

      for (let i = 0; i < numColumns; i++) {
        const column = document.createElement('div');
        column.className = 'column';
        column.style.left = `${i * columnWidth}px`;
        let columnContent = '';
        for (let j = 0; j < sequencesNeeded * 2; j++) {
          runes.forEach(rune => {
            columnContent += rune + '\n';
          });
        }
        column.textContent = columnContent;
        background.appendChild(column);
      }
    }

    // Resize handler
    function resize() {
      const screenW = window.innerWidth;
      const screenH = window.innerHeight;

      const aspectRatio = BASE_WIDTH / BASE_HEIGHT;
      let width, height;

      if (screenW / screenH < aspectRatio) {
        width = screenW;
        height = screenW / aspectRatio;
      } else {
        height = screenH;
        width = screenH * aspectRatio;
      }

      // Use floor to avoid any subpixel issues
      width = Math.floor(width);
      height = Math.floor(height);

      container.style.width = width + 'px';
      container.style.height = height + 'px';
      canvas.width = width;
      canvas.height = height;
      scale = width / BASE_WIDTH;

      createColumns();
    }

    // Initialize birds
    function initBirds() {
      birds = [];
      const now = performance.now();
      for (let i = 0; i < INITIAL_BIRDS; i++) {
        birds.push({
          id: nextBirdId++,
          x: 30 + Math.random() * 80,
          y: 60 + Math.floor(i / 8) * 40 + Math.random() * 30,
          vx: 0,
          vy: 0,
          alive: true,
          dying: false,
          color: BIRD_COLORS[i % BIRD_COLORS.length],
          rotation: 0,
          spinVelocity: 0,
          spawnTime: now
        });
      }
    }

    // Start game
    function startGame() {
      if (gameState === "playing") return; // <-- critical to stop Remix spam resets


      startMusic(); // Start background music on first game start
      initBirds();
      pipes = [];
      score = 0;
      currentPipeSpeed = PIPE_SPEED;
      lastPipeDistance = 0;
      lastTime = null;
      pendingFlaps = [];
      currentColorIndex = 0;
      pipesPassed = 0;
      colorTransitionProgress = 0;
      isTransitioningColor = false;
      gameState = 'playing';

      // Make all birds flap once at the start
      for (const bird of birds) {
        bird.vy = FLAP_VELOCITY;
      }
    }

    // Spawn birds from pipe
    function spawnBirdsFromPipe(pipe) {
      const now = performance.now();
      // Birds spawn from pipe and drift right to join the flock
      const driftVx = 200; // Rightward velocity to reach flock position

      for (let i = 0; i < 16; i++) {
        birds.push({
          id: nextBirdId++,
          x: pipe.x + Math.random() * PIPE_WIDTH,
          y: pipe.gapY + PIPE_GAP + 20 + Math.random() * 30,
          vx: driftVx,
          vy: -400 - Math.random() * 200,
          alive: true,
          dying: false,
          color: BIRD_COLORS[nextBirdId % BIRD_COLORS.length],
          rotation: 0,
          spinVelocity: 0,
          spawnTime: now
        });
      }
      for (let i = 0; i < 16; i++) {
        birds.push({
          id: nextBirdId++,
          x: pipe.x + Math.random() * PIPE_WIDTH,
          y: pipe.gapY - 20 - Math.random() * 30,
          vx: driftVx,
          vy: 100 + Math.random() * 200,
          alive: true,
          dying: false,
          color: BIRD_COLORS[nextBirdId % BIRD_COLORS.length],
          rotation: 0,
          spinVelocity: 0,
          spawnTime: now
        });
      }
    }

    // Handle flap at position
    function flapAt(x, y) {
      const now = performance.now();
      for (const bird of birds) {
        if (!bird.alive || bird.dying) continue;

        const birdCenterX = bird.x + BIRD_SIZE / 2;
        const birdCenterY = bird.y + BIRD_SIZE / 2;
        const dist = Math.sqrt((x - birdCenterX) ** 2 + (y - birdCenterY) ** 2);

        if (dist <= FLAP_RADIUS) {
          const delay = (dist / FLAP_RADIUS) * FLAP_MAX_DELAY;
          pendingFlaps.push({ birdId: bird.id, time: now + delay });
        }
      }
    }

    // Process pending flaps
    function processFlaps(now) {
      pendingFlaps = pendingFlaps.filter(flap => {
        if (now >= flap.time) {
          const bird = birds.find(b => b.id === flap.birdId);
          if (bird && bird.alive && !bird.dying) {
            bird.vy = FLAP_VELOCITY;
          }
          return false;
        }
        return true;
      });
    }

    // Update game state
    function update(deltaTime, now) {
      processFlaps(now);
      updateColorTransition(deltaTime);

      // Update birds
      for (let i = birds.length - 1; i >= 0; i--) {
        const bird = birds[i];

        if (bird.dying) {
          bird.vy += GRAVITY * 1.5 * deltaTime;
          bird.x += bird.vx * deltaTime;
          bird.y += bird.vy * deltaTime;
          bird.rotation += bird.spinVelocity * deltaTime;

          if (bird.y > BASE_HEIGHT + 50 || bird.x < -50 || bird.x > BASE_WIDTH + 50) {
            birds.splice(i, 1);
          }
          continue;
        }

        if (!bird.alive) {
          birds.splice(i, 1);
          continue;
        }

        bird.vy += GRAVITY * deltaTime;
        bird.y += bird.vy * deltaTime;

        // Apply horizontal velocity with decay (for pipe-spawned birds to drift to flock position)
        if (bird.vx !== 0) {
          bird.x += bird.vx * deltaTime;
          bird.vx *= Math.exp(-3 * deltaTime); // Exponential decay
          if (Math.abs(bird.vx) < 1) bird.vx = 0; // Stop when negligible
        }

        bird.rotation = Math.min(Math.max(bird.vy * 0.5, -30), 90);

        // Ground collision (bottom of screen)
        if (bird.y > BASE_HEIGHT - BIRD_SIZE) {
          bird.alive = false;
          bird.dying = true;
          bird.y = BASE_HEIGHT - BIRD_SIZE;
          bird.vy = -300 - Math.random() * 200;
          bird.vx = (Math.random() - 0.5) * 400;
          bird.spinVelocity = (Math.random() > 0.5 ? 1 : -1) * (600 + Math.random() * 400);
          continue;
        }

        // Pipe collision
        const isInvulnerable = now - bird.spawnTime < 500;
        if (bird.y > 0 && !isInvulnerable) {
          for (const pipe of pipes) {
            const birdRight = bird.x + BIRD_SIZE;
            const birdBottom = bird.y + BIRD_SIZE;
            const pipeRight = pipe.x + PIPE_WIDTH;

            if (birdRight > pipe.x && bird.x < pipeRight) {
              if (bird.y < pipe.gapY || birdBottom > pipe.gapY + PIPE_GAP) {
                bird.alive = false;
                bird.dying = true;
                bird.vy = -200 - Math.random() * 150;
                bird.vx = (bird.x < pipe.x + PIPE_WIDTH / 2 ? -1 : 1) * (200 + Math.random() * 200);
                bird.spinVelocity = (Math.random() > 0.5 ? 1 : -1) * (600 + Math.random() * 400);
                break;
              }
            }
          }
        }
      }

      // Update pipes
      for (let i = pipes.length - 1; i >= 0; i--) {
        const pipe = pipes[i];
        pipe.x -= currentPipeSpeed * deltaTime;

        if (!pipe.passed && pipe.x + PIPE_WIDTH < 30) {
          pipe.passed = true;
          const aliveBirds = birds.filter(b => b.alive && !b.dying);
          if (aliveBirds.length > 0) {
            score += aliveBirds.length;
            currentPipeSpeed += SPEED_INCREMENT; // Linear speed increase
            pipesPassed++;

            // Trigger smooth color transition every 8 pipes
            if (pipesPassed % PIPES_PER_COLOR === 0) {
              triggerColorTransition();
            }

            spawnBirdsFromPipe(pipe);
          }
        }

        if (pipe.x < -PIPE_WIDTH) {
          pipes.splice(i, 1);
        }
      }

      // Spawn new pipes
      lastPipeDistance += currentPipeSpeed * deltaTime;
      if (lastPipeDistance > INITIAL_PIPE_INTERVAL) {
        pipes.push({
          x: BASE_WIDTH,
          gapY: 80 + Math.random() * (BASE_HEIGHT - PIPE_GAP - 120),
          passed: false
        });
        lastPipeDistance = 0;
      }

      // Check game over
      const aliveBirds = birds.filter(b => b.alive && !b.dying);
      if (aliveBirds.length === 0 && birds.length === 0) {
        gameState = 'gameover';
        signalGameOver(score);
      }
    }

    // Draw functions
    function drawBird(bird) {
      ctx.save();
      ctx.translate((bird.x + BIRD_SIZE / 2) * scale, (bird.y + BIRD_SIZE / 2) * scale);
      ctx.rotate(bird.rotation * Math.PI / 180);

      const s = scale;
      const size = BIRD_SIZE * s;

      // Glow effect - skip on mobile for performance
      if (!IS_MOBILE) {
        ctx.shadowColor = bird.color;
        ctx.shadowBlur = 10 * s;
      }

      // Body
      ctx.fillStyle = bird.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, size / 2, size * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;

      // Eye white
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(size * 0.2, -size * 0.15, size * 0.12, 0, Math.PI * 2);
      ctx.fill();

      // Eye pupil
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(size * 0.25, -size * 0.15, size * 0.06, 0, Math.PI * 2);
      ctx.fill();

      // Beak
      ctx.fillStyle = '#FF6B35';
      ctx.beginPath();
      ctx.moveTo(size * 0.35, 0);
      ctx.lineTo(size * 0.55, -size * 0.05);
      ctx.lineTo(size * 0.55, size * 0.05);
      ctx.closePath();
      ctx.fill();

      // Wing
      ctx.fillStyle = bird.color;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      const wingY = bird.vy < 0 ? -size * 0.15 : size * 0.1;
      ctx.ellipse(-size * 0.1, wingY, size * 0.15, size * 0.1, bird.vy < 0 ? -0.5 : 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function drawPipe(pipe) {
      const s = scale;
      const x = pipe.x * s;
      const gapY = pipe.gapY * s;
      const width = PIPE_WIDTH * s;
      const gap = PIPE_GAP * s;
      const capHeight = 25 * s;
      const capWidth = (PIPE_WIDTH + 10) * s;

      const theme = getCurrentTheme();

      // Neon glow effect
      ctx.shadowColor = theme.glow;
      ctx.shadowBlur = 15 * s;

      // Top pipe
      ctx.fillStyle = theme.dark;
      ctx.fillRect(x, 0, width, gapY);
      ctx.strokeStyle = theme.glow;
      ctx.lineWidth = 2 * s;
      ctx.strokeRect(x, 0, width, gapY);

      // Top pipe cap
      ctx.fillStyle = theme.light;
      ctx.fillRect(x - 5 * s, gapY - capHeight, capWidth, capHeight);
      ctx.strokeRect(x - 5 * s, gapY - capHeight, capWidth, capHeight);

      // Bottom pipe
      ctx.fillStyle = theme.dark;
      ctx.fillRect(x, gapY + gap, width, BASE_HEIGHT * s - gapY - gap);
      ctx.strokeRect(x, gapY + gap, width, BASE_HEIGHT * s - gapY - gap);

      // Bottom pipe cap
      ctx.fillStyle = theme.light;
      ctx.fillRect(x - 5 * s, gapY + gap, capWidth, capHeight);
      ctx.strokeRect(x - 5 * s, gapY + gap, capWidth, capHeight);

      ctx.shadowBlur = 0;
    }

    function drawScore() {
      const theme = getCurrentTheme();

      ctx.shadowColor = theme.glow;
      ctx.shadowBlur = 20 * scale;

      ctx.font = `bold ${72 * scale}px Arial Black, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      // Shadow layer for depth (darker version of glow)
      ctx.fillStyle = theme.dark;
      ctx.fillText(score, BASE_WIDTH * scale / 2 + 4 * scale, 40 * scale + 4 * scale);
      ctx.fillStyle = theme.glow;
      ctx.fillText(score, BASE_WIDTH * scale / 2, 40 * scale);

      ctx.shadowBlur = 0;
    }

    function drawStartScreen() {
      const theme = getCurrentTheme();

      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.shadowColor = theme.glow;
      ctx.shadowBlur = 20 * scale;

      ctx.fillStyle = theme.glow;
      ctx.font = `bold ${36 * scale}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üê¶ BAFILYRD üê¶', BASE_WIDTH * scale / 2, BASE_HEIGHT * scale / 2 - 50 * scale);

      // Start button
      const btnX = BASE_WIDTH * scale / 2 - 80 * scale;
      const btnY = BASE_HEIGHT * scale / 2;
      const btnW = 160 * scale;
      const btnH = 50 * scale;

      ctx.fillStyle = theme.glow;
      ctx.beginPath();
      ctx.roundRect(btnX, btnY, btnW, btnH, 25 * scale);
      ctx.fill();

      ctx.shadowBlur = 0;

      ctx.fillStyle = '#0a0a0a';
      ctx.font = `bold ${20 * scale}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('START', BASE_WIDTH * scale / 2, btnY + btnH / 2);
    }

    function drawGameOverScreen() {
      // Only show overlay and UI if NOT running inside Remix
      // (Remix handles its own game over UI)
      if (isInRemix()) return;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.shadowColor = '#ff0055';
      ctx.shadowBlur = 20 * scale;

      ctx.fillStyle = '#ff0055';
      ctx.font = `bold ${36 * scale}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('GAME OVER', BASE_WIDTH * scale / 2, BASE_HEIGHT * scale / 2 - 50 * scale);

      // Play again button
      const btnX = BASE_WIDTH * scale / 2 - 100 * scale;
      const btnY = BASE_HEIGHT * scale / 2;
      const btnW = 200 * scale;
      const btnH = 50 * scale;

      ctx.shadowColor = '#00ff88';
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.roundRect(btnX, btnY, btnW, btnH, 25 * scale);
      ctx.fill();

      ctx.shadowBlur = 0;

      ctx.fillStyle = '#0a0a0a';
      ctx.font = `bold ${20 * scale}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('PLAY AGAIN', BASE_WIDTH * scale / 2, btnY + btnH / 2);
    }

    // Main render function
    function render() {
      // Clear canvas (transparent to show rune background)
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const pipe of pipes) {
        drawPipe(pipe);
      }

      for (const bird of birds) {
        drawBird(bird);
      }

      if (gameState === 'playing') {
        drawScore();
      } else if (gameState === 'start') {
        drawStartScreen();
      } else if (gameState === 'gameover') {
        drawScore();
        drawGameOverScreen();
      }
    }

    // Game loop
    function gameLoop(currentTime) {
      if (lastTime === null) lastTime = currentTime;
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
      lastTime = currentTime;

      if (gameState === 'playing') {
        update(deltaTime, currentTime);
      }

      render();
      requestAnimationFrame(gameLoop);
    }

    // Helpers
    function isInsideButton(x, y, btnX, btnY, btnW, btnH) {
      return x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH;
    }

    function handleStartClick(x, y) {
      const btnW = gameState === "start" ? 160 : 200;
      const btnH = 50;
      const btnX = BASE_WIDTH / 2 - btnW / 2;
      const btnY = BASE_HEIGHT / 2;

      if (isInsideButton(x, y, btnX, btnY, btnW, btnH)) {
        startGame();
      }
    }

    // Event handlers
    function getGameCoords(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX ?? e.touches?.[0]?.clientX ?? 0;
      const clientY = e.clientY ?? e.touches?.[0]?.clientY ?? 0;
      return {
        x: (clientX - rect.left) / scale,
        y: (clientY - rect.top) / scale
      };
    }

    canvas.addEventListener("click", (e) => {
      const { x, y } = getGameCoords(e);

      if (gameState === "playing") {
        mouseX = x;
        mouseY = y;
        flapAt(x, y);
      } else {
        handleStartClick(x, y);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const { x, y } = getGameCoords(e);
      mouseX = x;
      mouseY = y;
    });

    canvas.addEventListener(
      "touchstart",
      (e) => {
        e.preventDefault();
        const { x, y } = getGameCoords(e);

        if (gameState === "playing") {
          mouseX = x;
          mouseY = y;
          flapAt(x, y);
        } else {
          handleStartClick(x, y);
        }
      },
      { passive: false },
    );

    document.addEventListener("keydown", (e) => {
      if (e.code !== "Space") return;
      if (e.repeat) return;

      e.preventDefault();

      if (gameState === "playing") {
        flapAt(mouseX, mouseY);
      }
    });

    window.addEventListener('resize', resize);

    // Start
    resize();
    initRemixSDK();
    requestAnimationFrame(gameLoop);
  </script>
</body>

</html>